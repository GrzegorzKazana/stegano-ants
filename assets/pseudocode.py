# high level embedding process description
def embed(transport_image, data):
    '''
    arguments
        transport_image - structure representing RGB pixels of an input image
        data - iterator of bits which will be hidden in the steganogram

    return value:
        structure representing RGB pixels of a steganogram
    '''

    # calculate how many bits should be substituted in each pixel
    # mask must have the same dimensions as input image
    mask = generate_masking_matrix(transport_image)

    # initialize steganogram with copy of input image
    steganogram = transport_image.copy()

    for pixel in transport_image:
        number_of_hidden_bits = mask[pixel.x][pixel.y]
        hidden_bits = data.take(number_of_hidden_bits)

        # replace n least significant bits with respect to the mask
        steganogram[pixel.x][pixel.y] = substitute_n_least_significant_bits(steganogram[pixel.x][pixel.y], hidden_bits)

    return steganogram


# high level extraction process description
def extract(transport_image, steganogram):
    '''
    arguments:
        transport_image - structure representing RGB pixels of an input image
        steganogram - structure representing RGB pixels of a steganogram

    return value:
        iterator of extracted bits
    '''

    # calculate how much bits should be substituted in each pixel
    # mask must have the same dimensions as input image
    mask = generate_masking_matrix(transport_image)
    data = []

    for pixel in steganogram:
        # retrive number of hidden bits according to masking matrix
        number_of_hidden_bits = mask[pixel.x][pixel.y]
        hidden_bits = get_n_least_significant_bits(pixel, number_of_hidden_bits)

        data = data.concat(hidden_bits)

    return data


def generate_masking_matrix(transport_image):
    '''
    arguments:
        transport_image - structure representing RGB pixels of an input image

    return value:
        matrix of dimensions equal to that of transport_image,
        each value represents how much data can be hidden in each pixel
    '''

    # creates graph representation of an image
    # using one of proposed methods
    graph = convert_image_to_graph(transport_image)

    # runs ant colony for specific number of iterations
    # returns pheromone trail accumulated by the ants
    pheromone = apply_ant_colony(graph)

    # based on the pheromone generated by ants
    # calculate how much bits should be substituted in each pixel
    return convert_pheromone_to_masking_matrix(pheromone)


def convert_image_to_graph(transport_image):
    pass

def convert_pheromone_to_masking_matrix(pheromone):
    pass

def convert_image_to_graph_vertex_based(transport_image):
    '''
    arguments:
        transport_image - structure representing RGB pixels of an input image

    return value:
        graph defined by adjacency matrix
    '''

    # initialize empty adjacency matrix representing the graph
    # matrix is of N x N size, where N is the number of pixels in input image
    adjacency_matrix = Matrix(transport_image.size, transport_image.size).fill(Infinity)

    for pixel in transport_image:
        # neighbourhood can be 4- or 8-adjacent
        for neighbour in pixel.neighbours:
            # calculate distance between vertices
            # based on the RBG values of neighbouring pixels
            # `pixel_difference` represents any difference/similarity metric
            adjacency_matrix[pixel.index][neighbour.index] = pixel_difference(pixel, neighbour)

    return adjacency_matrix

def convert_pheromone_to_masking_matrix_vertex_based(transport_image, pheromone):
    '''
    arguments:
        transport_image - structure representing RGB pixels of an input image
        pheromone - structure mapping each graph edge to real number representing
            pheromone intensity between vertices

    return value:
        matrix of dimensions equal to that of transport_image,
        each value represents how much data can be hidden in each pixel
    '''

    # initialize empty masking matrix
    masking_matrix = Matrix(transport_image.width, transport_image.height).fill(0)

    for pixel in transport_image:
        pheromone_sum = 0

        # sum pheromone intensity of all edges adjacent to given vertex
        for neighbour in pixel.neighbours:
            edge = pheromone.get_edge(pixel, neighbour)
            pheromone_sum += edge.pheromone_value

        # apply arbitrary `f` function which maps pheromone intensity level
        # to number of bits which can be used for data hiding
        masking_matrix[pixel.x][pixel.y] += f(pheromone_sum)

    return masking_matrix


def convert_image_to_graph_edge_based(transport_image, number_of_vertices):
    '''
    arguments:
        transport_image - structure representing RGB pixels of an input image
        number_of_vertices - target number of graph vertices

    return value:
        graph defined by adjacency matrix
    '''

    # based on the number of vertices, calculate the number of edges in fully connected graph
    number_of_edges = number_of_vertices * (number_of_vertices - 1) / 2

    # divide image into `number_of_edges` using superpixels/k-means/etc...
    segments = segment_image(transport_image, number_of_edges)

    # initialize empty adjacency matrix representing the graph
    adjacency_matrix = Matrix(number_of_vertices, number_of_vertices).fill(Infinity)

    for segment, index in segments:
        # calculate edge length which is related to variance between
        # pixels belonging to the same segment
        edge_length = pixel_variance(segment)

        # each segment coresponds to one graph edge,
        # which are assigned to specific vertices
        vertex_from_index = calculate_vertex_from_index(index)
        vertex_to_index = calculate_vertex_to_index(index)

        adjacency_matrix[vertex_from_index][vertex_to_index] = edge_length

    return adjacency_matrix


def convert_pheromone_to_masking_matrix_edge_based(transport_image, pheromone):
    '''
    arguments:
        transport_image - structure representing RGB pixels of an input image
        pheromone - structure mapping each graph edge to real number representing
            pheromone intensity between vertices

    return value:
        matrix of dimensions equal to that of transport_image,
        each value represents how much data can be hidden in each pixel
    '''

    # initialize empty masking matrix
    masking_matrix = Matrix(transport_image.width, transport_image.height).fill(0)

    for edge in pheromone:
        # each graph edge coresponds to group of pixels in the input image
        segment = get_image_segment_represented_by_edge(edge)

        for pixel in segment:
            # apply arbitrary `f` function which maps pheromone intensity level
            # to number of bits which can be used for data hiding
            masking_matrix[pixel.x][pixel.y] = f(edge.pheromone_value)

    return masking_matrix


def apply_ant_colony(graph):
    pass

def substitute_n_least_significant_bits():
    pass

def get_n_least_significant_bits():
    pass

class Matrix:
    pass

def pixel_difference():
    pass