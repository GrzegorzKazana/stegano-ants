\chapter{Aplikacja steganograficzna wykorzystująca systemy mrówkowe}\label{chap:implementation}
{
    % specyfikacja zewnętrzna
    %   - uruchamianie
    %   - parametry
    %   - format danych wejściowych
    %   - format danych wyjściowych
    %   - przykłady użycia
    %
    % specyfikacja wewnętrzna
    %   - opis modułów
    %   - opis najważniejszych struktur (graf, mrowisko, itp)
    %   - opis najważniejszych cech (trait) (i krótko i implementacjach (?))
    %
    % walidacja i testowanie
    %   - jak przetestowano aplikację
    %       - unity
    %       - property based testy
    %   - kompilacja jako walidacja (memory & type safety)
    Celem utworzonej aplikacji jest implementacja metod opisanych w poprzednim rozdziale \ref{sec:method} oraz
    umożliwienie porównywania uzyskanych rezultatów dla różnych parametrów wejściowych.

    Do dodatkowych zadań utworzonego programu należy między innymi wczytywanie plików graficznych z dysku, uruchomienie
    wskazanego rodzaju systemu mrówkowego oraz wykorzystanie uzyskanego śladu feromonowego do utworzenia macierzy
    maskującej, która posłuży do ukrycia wskazanych danych w bitmapie.

    % SPECYFIKACJA ZEWNĘTRZNA
    \section{Dokumentacja użytkowa}
    {
        %
        Ponieważ funkcjonalność aplikacji była bardziej znaczącym aspektem niż jej interfejs, program zdecydowano się
        zaimplementować jako aplikację konsolową w postaci pliku \texttt{stegano-ants}. Pomimo wady w postaci mniejszej
        przystępności dla niedoświadczonego użytkownika, takie rozwiązanie ma również swoje zalety. Umożliwia
        automatyczne uruchamianie aplikacji dla różnych zestawów danych za pomocą zewnętrznych skryptów i programów, co
        okazało się bardzo wartościowe podczas ewaluacji rezultatów dla dużej liczby różnych parametrów
        uruchomieniowych.

        % HELP
        Użytkownik może się zapoznać z całym wachlarzem opcji uruchomieniowych poprzez uruchomienie
        programu z flagą \textit{--help} (listing \ref{code:help}). Dokładny opis każdego z parametrów zamieszczono w
        kolejnym podrozdziale.

        \begin{lstlisting}[basicstyle=\tiny, caption=Pomoc programu, label=code:help]
USAGE:
stegano-ants [FLAGS] [OPTIONS] --dispatcher <dispatcher> --updater <updater> <SUBCOMMAND>

FLAGS:
-h, --help             Prints help information
-q, --quiet
    --verbose-files    verbose filenames of output files
-V, --version          Prints version information

OPTIONS:
-a, --ants <ants>                          amount of ants, by default number of nodes
    --converter <converter>
        converter type in format <type>:<args> [default: i:spatial]

-c, --cycles <cycles>                      number of traning cycles
-d, --dispatcher <dispatcher>              dispatcher definition in format <type>:<args>
    --mask-width <mask-width>
        dimension of the pheromone mask, directly affects graph size, height is calculated
        automatically

    --seed <seed>                          rng seed [default: 42]
-s, --steps <steps>
        number of ant steps in single cycle, by default number of nodes

    --stop-after <stop-after>
        train until number of cycles does not provide improvement

    --target-capacity <target-capacity>    target capacity
-u, --updater <updater>                    updater type in format <type>:<args>

SUBCOMMANDS:
embed
extract
help       Prints this message or the help of the given subcommand(s)
tsp
        \end{lstlisting}

        \subsection{Opis parametrów programu}
        {
            %
            Program działa w trzech trybach, a każdy z nich jest związany z odpowiednimi argumentami. Istnieją też
            parametry niezwiązane z wybraną podkomendą. Należą do nich głównie parametry systemu mrówkowego.
            Szczegółowy opis każdego z nich zawiera lista:

            \begin{itemize}
                \item \textbf{seed} - ziarno generatora liczb losowych, umożliwia powtarzalność wyników. Domyślnie
                przyjmuje wartość \textit{42}.
                \item \textbf{ants} - liczba mrówek w mrowisku. Jeśli nie zostanie podana, system mrowiskowy zostanie
                zainicjowany z liczbą mrówek równą liczbie wierzchołków grafu.
                \item \textbf{steps} - maksymalna liczba kroków wykonywanych przez mrówki w jednym cyklu. Znajduje
                zastosowanie jedynie w metodzie budowy grafu opartej na wierzchołkach. Domyślnie liczba kroków mrówek
                jest równa liczbie wierzchołków grafu.
                \item \textbf{dispatcher} - rodzaj strategii wyboru krawędzi przez mrówki. Odpowiada metodom opisanym w
                sekcji\ref{sec:code_ant_colony}. Dostępne wartości to \texttt{basic}, \texttt{biased} oraz
                \texttt{colony}. Każdą z wartości może następować lista parametrów wybranej strategii. Jeśli lista
                parametrów nie zostanie podana, zastosowane będą automatycznie dobrane wartości dla wskazanego problemu.
                \item \textbf{updater} - rodzaj strategii nanoszenia śladu feromonowego odpowiadających różnym systemom
                mrówkowym. Dostępne wartości to \texttt{const}, \texttt{avg}, \mbox{\texttt{cycle},} \texttt{colony} oraz \texttt{maxmin}. Podobnie jak w przypadku argumentu \textbf{dispatcher},
                możliwe jest podanie dodatkowych parametrów do każdej strategii po oddzieleniu ich znakiem
                ,,\texttt{:}''.
                \item \textbf{converter} - strategia przekształcenia bitmapy w graf, które zostały opisane w
                \ref{sec:method}. Dostępne wartości to \texttt{spatial}, \texttt{window}, \texttt{kmeans} oraz
                \texttt{superpixels}. Każda z nich może zostać poprzedzona znakami ,,\texttt{i:}'' aby jednocześnie
                odwrócić długości wygenerowanego grafu i luminancję każdego z pikseli macierzy maskującej.
                \item \textbf{cycles} - określa liczbę iteracji systemu mrówkowego. Jeśli nie jest podana, musi zostać
                podany argument \textbf{stop-after}.
                \item \textbf{stop-after} - określa po ilu iteracjach bez polepszenia rezultatów przeszukiwanie powinno
                się zatrzymać.
                \item \textbf{mask-width} - pozwala na przeskalowanie obrazu na którego podstawie tworzony jest graf.
                \item \textbf{target-capacity} - pozwala na określenie docelowej pojemności steganogramu. Wykorzystywane
                podczas eksperymentów i pomiarów degradacji jakości obrazu. Przyjmuje wartości liczbowe z jednostką
                \texttt{B}, \texttt{kB} lub \texttt{MB}.
                \item \textbf{quiet} - jeśli zostanie podany ten argument, program nie będzie drukował rezultatów na
                strumień wyjścia.
                \item \textbf{verbose-files} - decyduje czy generowane artefakty (steganogram, macierz konwersji na
                graf i macierz maskująca) będą posiadały w nazwie znacznik czasu oraz argumenty uruchomienia.
            \end{itemize}


            Po podaniu głównych argumentów, użytkownik musi wybrać tryb pracy programu. Należą do nich:

            \begin{enumerate}
                \item \textbf{embed} - tryb ukrywania informacji. Wymaga podania argumentów:
                    \begin{itemize}
                        \item \textbf{image} - ścieżka do obrazu nośnego,
                        \item \textbf{data} - ścieżka do pliku tekstowego zawierającego ukrywaną wiadomość.
                    \end{itemize}

                    Rezultatem działania programu w tym trybie są 4 obrazy, które znajdują się w tym samym folderze co
                    obraz nośny. Każdy z wygenerowanych obrazów jest opatrzony przyrostkiem definiującym jego znaczenie.

                    \begin{itemize}
                        \item \textbf{steg} - utworzony steganogram,
                        \item \textbf{pher} - macierz maskująca w postaci bitmapy,
                        \item \textbf{pher\_scaled} - macierz maskująca przeskalowana w taki sposób, aby pomieściła
                        zadaną liczbę danych,
                        \item \textbf{conv} - przedstawia proces konwersji bitmapy na graf. Każdy piksel posiada
                        luminancję związaną z odległością na grafie.
                    \end{itemize}

                \item \textbf{extract} - tryb wydobywania informacji z steganogramu. Wymaga podania argumentów:
                    \begin{itemize}
                        \item \textbf{image} - ścieżka do obrazu nośnego,
                        \item \textbf{steg} - ścieżka do steganogramu.
                    \end{itemize}

                    Odzyskana informacja zostanie wyświetlona na strumieniu wyjściowym procesu.

                \item \textbf{tsp} - tryb rozwiązywania problemu komiwojażera. Możliwe jest uruchomienie go z
                następującymi argumentami:
                    \begin{itemize}
                        \item \textbf{n-cities} - powoduje wygenerowanie losowego grafu o zadanej liczbie wierzchołków,
                        \item \textbf{graph} - ścieżka do pliku \textit{.csv} zawierającego listę współrzędnych
                        opisujących wierzchołki grafu.
                    \end{itemize}

                    Rezultatem pracy tego trybu jest długość najkrótszej ścieżki oraz kolejność odwiedzanych wierzchołków.
            \end{enumerate}
            %
        }

        \subsection{Przykłady użycia}
        {
            Poniżej zamieszczono przykładowe uruchomienia programu:

            \begin{enumerate}
                \item Ukrycie danych we wskazanym pliku przy użyciu systemu mrowiskowego oraz wierzchołkowej metody
                budowy grafu.

                \begin{lstlisting}
    stegano-ants \
        --cycles=10 \
        --ants=1000 \
        --steps=100 \
        --dispatcher=colony \
        --updater=colony \
        embed \
        --data=lorem.txt \
        --image=photo.bmp
                \end{lstlisting}

                \item Wydobycie danych z wskazanego steganogramu przy użyciu systemu mrowiskowego oraz wierzchołkowej
                metody budowy grafu.

                \begin{lstlisting}
    stegano-ants \
        --cycles=10 \
        --ants=1000 \
        --steps=100 \
        --dispatcher=colony \
        --updater=colony \
        extract \
        --steg=photo_pher.bmp \
        --image=photo.bmp
                \end{lstlisting}

                \item Ukrycie danych we wskazanym pliku przy użyciu systemu max-min z ustalonymi parametrami $\alpha=1$
                i $\beta=2$ oraz metodą podziału na 50 superpikseli.

                \begin{lstlisting}
    stegano-ants \
        --cycles=10 \
        --ants=1000 \
        --steps=100 \
        --dispatcher=biased:1,2 \
        --updater=maxmin \
        --converter=superpixels:50 \
        embed \
        --data=lorem.txt \
        --image=photo.bmp
                \end{lstlisting}

                \item Ukrycie danych we wskazanym pliku przy użyciu systemu max-min z ustalonymi parametrami $\alpha=1$
                i $\beta=2$.

                \begin{lstlisting}
    stegano-ants \
        --cycles=10 \
        --ants=1000 \
        --steps=100 \
        --dispatcher=biased:1,2 \
        --updater=maxmin \
        embed \
        --data=lorem.txt \
        --image=photo.bmp
                \end{lstlisting}

                \item Poszukiwanie rozwiązania problemu komiwojażera opisanego plikiem \textit{.csv} za pomocą systemu o
                feromonie cyklicznym. Program zatrzyma działanie po 10 iteracjach bez poprawy rezultatu.

                \begin{lstlisting}
    stegano-ants \
        --stop-after=10 \
        --dispatcher=biased \
        --updater=cycle \
        tsp \
        --graph=tsp.csv
                \end{lstlisting}
            \end{enumerate}
        }
        %
    }

    % SPECYFIKACJA WEWNĘTRZNA
    \section{Dokumentacja programowa}
    {
        % WYKORZYSTANE NARZĘDZIA
        Do implementacji aplikacji umożliwiającej ukrywanie danych w obrazach cyfrowych za pomocą przedstawionych metod
        wykorzystano język \textit{Rust}. \textit{Rust} jest kompilowanym językiem niskiego poziomu, którego kod
        wynikowy nie jest uruchamiany za pomocą maszyny wirtualnej. Nie posiada również mechanizmu odśmiecania pamięci,
        (ang. \textit{garbage collection}) ani automatycznego zliczania referencji. W przeciwieństwie do języków
        \textit{C} oraz \textit{C++} obowiązek zarządzania pamięcią i gwarantowania bezpieczeństwa jej użycia jest w
        dużej mierze przeniesiony z dewelopera na rygorystyczny kompilator \cite{Cosmin2019RustT, Matsakis2014TheRL,
        RustHomePage}.

        Głównymi celami realizowanymi przez język \textit{Rust} jest umożliwienie pisania aplikacji wymagających dużej
        wydajności, współbieżności oraz bezpieczeństwa przy wykorzystaniu nowoczesnych praktyk programistycznych.
        Kolejnym atutem tego języka jest wbudowany mechanizm zarządzania pakietami \textit{Cargo} umożliwiający
        bezproblemowe korzystanie z bogatego wachlarza otwartoźródłowych bibliotek.

        \textit{Rust} jest językiem wieloparadygmatowym, lecz wiele cech będących fundamentem jego popularności oraz
        bezpieczeństwa czerpie z języków funkcyjnych. Umożliwia pisanie wydajnego deklaratywnego kodu dzięki
        rozbudowanym iteratorom, analogicznym do przetwarzania strumieniowego z języka \textit{Java}, oraz algebraicznym
        typom danych. Ważną decyzją podjętą podczas projektowania języka było zdecydowanie się na wykorzystanie monad
        \textit{Option} oraz \textit{Result}, co pozwoliło na rezygnację z mechanizmu wyjątków, zapewnienie
        bezpieczeństwa odwołań pod kątem pustych referencji (ang. \textit{null safety}) oraz umożliwienie kompilatorowi
        wychwycenia znacznej części najczęściej popełnianych błędów.

        Ekspresywny system typów pozwala na pisanie rozszerzalnego i generycznego kodu. Język \textit{Rust} pozbawiony
        jest mechanizmu dziedziczenia, które nadużywane może być źródłem nieoczekiwanych zachowań oraz błędów związanych
        z dzieleniem stanu pomiędzy poszczególnymi klasami bazowymi oraz konfliktami identyfikatorów. Alternatywnym
        rozwiązaniem pozwalającym na wielokrotne wykorzystywanie zachowań są cechy (ang. \textit{trait}). Cechy
        umożliwiają jedynie współdzielenie interfejsu oraz domyślnych implementacji funkcji związanych z typem danych,
        lecz nie pozwalają na współdzielenie stanu. Są mechanizmem zbliżonym do klas typów (ang. \textit{typeclasses})
        znanych z funkcyjnego języka \textit{Haskell}.

        Kod źródłowy aplikacji został podzielony w taki sposób, że odzwierciedla poruszane domeny. Powstały trzy główne
        moduły aplikacji: moduł systemu mrówkowego (\textit{ant\_colony}), moduł przetwarzania obrazów (\textit{images})
        i moduł steganograficzny (\textit{steganography}).


        \subsection{Moduł systemu mrówkowego}\label{sec:code_ant_colony}
        {
            W powyższym module zawarto implementację generycznego systemu mrówkowego, który jest parametryzowany
            strategiami wyboru krawędzi oraz nanoszenia śladu feromonowego. W ten sposób możliwe było efektywne
            zaimplementowanie wszystkich testowanych modeli systemów: z feromonem stałym, średnim, cyklicznym, systemu
            mrowiskowego oraz systemu max-min.

            % ANT-DISPATCHER
            Strategie wyboru krawędzi określone są cechą (ang. \textit{trait}) \texttt{AntDispatcher}. Jest to interfejs
            wymagający od każdej implementującej go struktury zapewnienia funkcji wybierającej kolejną krawędź dla
            wskazanej mrówki, grafu oraz śladu feromonowego. Cecha posiada również domyślną implementację funkcji
            odpowiedzialnej za umieszczenie zadanej liczby mrówek na wierzchołkach grafu w sposób losowy.

            Strukturami implementującymi cechę \texttt{AntDispatcher} są:

            \begin{itemize}
                \item \textit{BasicAntDispatcher} implementująca wzór \ref{eqt:edge_dispatch_propab} dla $\alpha = \beta
                = 1$,
                \item \textit{BiasedAntDispatcher} implementująca wzór \ref{eqt:edge_dispatch_propab}, jest
                wykorzystywana w wszystkich systemach z wyjątkiem systemu mrowiskowego,
                \item \textit{ColonyAntDispatcher} implementująca zasadę wyboru krawędzi w systemie mrowiskowym, będącą opisaną wzorem \ref{eqt:ant_colony_dispatch}.
            \end{itemize}

            % PHEROMONE-UPDATER
            Kolejną kluczową cechą należącą do tego modułu jest \texttt{PheromoneUpdater}, opisująca strategie
            odkładania śladu feromonowego na skutek ruchu mrówek. Interfejs wymaga implementacji funkcji inicjalizacji
            struktury feromonu, jego aktualizacji po wykonaniu kroku przez wszystkie mrówki oraz po wykonaniu całego
            cyklu. Dwie ostatnie funkcje mają domyślną postać funkcji identycznościowej.

            Powyższa cecha jest implementowana przez następujące struktury:

            \begin{itemize}
                \item \textit{ConstantPheromoneUpdater} nanoszący stała wartość na każdą odwiedzoną krawędź grafu, jest
                opisany wzorem \ref{eqt:pheromone-density},
                \item \textit{AveragePheromoneUpdater} odpowiada modelowi o feromonie średnim, opisanym wzorem \ref{eqt:pheromone-quantity},
                \item \textit{CyclicalPheromoneUpdater} aktualizujący ślad dla krawędzi w proporcji do długości trasy do
                której należy (wzór \ref{eqt:pheromone-cycle}),
                \item \textit{ColonyPheromoneUpdater} nanoszący ślad w każdym kroku algorytmu oraz po zakończeniu cyklu
                dla krawędzi należących do najkrótszej ścieżki (wzór \ref{eqt:pheromone-cycle}),
                \item \textit{MaxMinPheromoneUpdater} implementujący logikę aktualizacji śladu feromonowego w systemie
                max-min (wzór \ref{eqt:ant_colony_global_update_2} oraz \ref{eqt:ant_colony_local_update_2}).
            \end{itemize}

            Kolejnym ważnym elementem powyższego modułu jest struktura śladu feromonowego \texttt{Pheromone}. Jej
            implementacja jest oparta na tablicy asocjacyjnej (ang. \textit{HashMap}) przypisującej każdemu
            identyfikatorowi krawędzi wartość zmiennoprzecinkową. Zawiera metody umożliwiające skalowanie,
            inkrementację i normalizację wartości mapy.

            Ostatnim istotnym elementem modułu systemu mrówkowego jest struktura reprezentująca graf. Jego implementacja
            również wykorzystuje tablicę asocjacyjną, której kluczami są identyfikatory wierzchołków a wartościami
            struktury wierzchołków zawierające listę sąsiedztwa.
        }

        \subsection{Moduł przetwarzania obrazów}
        {
            Wszelkie operacje związane z odczytem i manipulacją obrazów zostały zawarte w module \texttt{images}. Można
            w nim wyszczególnić strukturę \texttt{Image} oraz związane z nią funkcje pozwalające na wczytywanie obrazu z
            dysku, manipulację rozmiarem oraz przekształcenie do struktury \texttt{PixelMap} będącej wygodną abstrakcją
            nad bitmapami \textit{RGB}. Struktura \texttt{PixelMap} pozwala na iterację kolejnych pikseli, iterację
            pikseli sąsiadujących z wskazanymi współrzędnymi, dowolne przekształcenie każdego piksela za pomocą
            przekazanej funkcji oraz wyznaczenie negatywu obrazu.

            Najbardziej złożoną częścią tego modułu jest cecha \texttt{ImageGraphConverter} oraz implementujące je
            struktury. Jej zadaniem przekształcenie dowolnej instancji bitmapy do grafu oraz przekształcenie śladu
            feromonowego w macierz maskującą, która jest reprezentowana przez instancję struktury \texttt{PixelMap}.

            Do struktur implementujących powyższą cechę należą:

            \begin{itemize}
                \item \textit{SpatialEdgeChangeConverter} implementująca metodę opisaną w sekcji
                \ref{subsec:vertex-method},
                \item \textit{WindowToEdgeConverter} odpowiedzialną za segmentację obrazu na nienachodzące na siebie
                prostokąty, opisaną w sekcji \ref{subsec:edge-method},
                \item \textit{KMeansConverter} dzielącą obraz na grupy pikseli o zbliżonej wariancji sąsiadujących pikseli,
                \item \textit{SuperPixelConverter} segmentująca obraz na zadaną liczbę superpikseli według algorytmu
                \textit{SLIC}.
            \end{itemize}
        }

        \subsection{Moduł steganograficzny}
        {
            Ostatnim modułem aplikacji jest moduł odpowiedzialny za ukrywanie informacji we wskazanej bitmapie na
            podstawie macierzy maskującej. Zarówno bitmapa jak i macierz maskująca są reprezentowane przez struktury
            \texttt{PixelMap}. Strukturą implementującą powyższą funkcjonalność jest \texttt{MaskImageEmbedder}. W
            trakcie ukrywania informacji wykorzystywany jest iterator bitów pozwalający na odczyt zadanej liczby
            kolejnych bitów wiadomości.

            W module zawarto również implementację podstawowych miar jakości obrazów, takich jak błąd średniokwadratowy
            i szczytowy stosunek sygnału do szumu.
        }
    }



    % WALIDACJA I TESTOWANIE
    \section{Weryfikacja i testowanie}
    {
        W celu zapewnienia pożądanego działania oraz powtarzalności rezultatów aplikacja została w znacznym stopniu
        pokryta testami jednostkowymi. Umożliwiło to natychmiastowe wykrycie nieoczekiwanych zmian w działaniu programu
        oraz umożliwiło dynamiczny rozwój kolejnych modułów aplikacji.

        Kolejnym istotnym zagadnieniem związanym z wykorzystanymi metodami zapewnienia jakości oprogramowania są testy
        oparte na właściwościach (ang. \textit{property based testing}). Jest to technika polegająca na testowaniu kodu
        dla bardzo dużej liczby generowanych losowo danych wejściowych i sprawdzaniu czy pewne fundamentalne założenia
        dotyczące danych wyjściowych są wciąż spełnione. Przykładowo, test oparty na właściwości funkcji sortującej
        tablicę zawierającą wartości liczbowe może sprawdzać, czy każdy kolejny element posortowanej tablicy jest
        większy bądź równy poprzedniemu. W ten sposób możliwe jest zweryfikowanie działania kodu bez określania
        konkretnych zestawów danych.

        W aplikacji wykorzystano testy oparte na właściwościach do zapewnienia odwracalności procesu ukrywania i
        wydobywania danych z obrazu (złożenie funkcji ukrywającej i funkcji wydobywającej powinno być funkcją
        identycznościową z względu na argument ukrywanych danych) oraz zapewniania unikalności generowanych
        identyfikatorów krawędzi łączących wskazane wierzchołki grafu za pomocą metody zaproponowanej przez M. Szudzika
        \cite{SzudzikFn}.

        \subsection{Rozwiązywanie problemu komiwojażera}
        {
            %
            Aby zweryfikować poprawność implementacji modułu systemu mrówkowego postanowiono sprawdzić jego efektywność
            w rozwiązywaniu problemu komiwojażera. Krok ten również umożliwił implementację pomocniczych heurystyk
            służących do automatycznego doboru parametrów strategii wyboru krawędzi przez mrówki oraz odkładania śladu
            feromonowego. Uzyskane zależności wyprowadzono na postawie eksperymentów oraz wskazówek znajdujących się w
            pracach opisujących poszczególne systemy mrówkowe \cite{Dorigo1991AntSA, Dorigo1997AntCS,
            Sttzle2000MAXMINAS}.

            W tabeli \ref{tab:impl-tsp-results-oliver} oraz \ref{tab:impl-tsp-results-kroa} zamieszczono uzyskane
            rezultaty znanych z literatury problemów o trzydziestu (\textit{oliver30}) i stu miastach
            (\textit{kroa100}), wraz z powszechnie znanymi najlepszymi rozwiązaniami. Parametry poszczególnych wariantów
            systemów mrówkowych były konfigurowane za pomocą opracowanych heurystyk. Przyjęto również że liczba mrówek
            jest równa liczbie wierzchołków grafu.
%
            \begin{table}[H]
                \centering
                \caption{Uzyskane rozwiązania problemu \textit{oliver30}}
                \begin{tabular}{ |l|c c c|c c| }
                    \hline
                    & \multicolumn{3}{c|}{średnia z 10} & \multicolumn{2}{c|}{najlepszy wynik} \\
                    \hline
                    Rodzaj systemu & rozwiązanie & $\sigma$ & iteracja & rozwiązanie & iteracja \\
                    \hline
                    \textit{Ant Density} & 457.095 & 19.239 & 38 & 423.949 & 25 \\
                    \textit{Ant Quantity} & 426.195 & 1.760 & 302 & 423.912 & 164 \\
                    \textit{Ant Cycle} & 426.009 & 0.928 & 178 & 424.635 & 247 \\
                    \textit{Ant Colony} & 429.092 & 3.712 & 216 & 423.912 & 520 \\
                    \textit{Max-min Ant System} & 424.485 & 0.516 & 78 & 423.741 & 82 \\
                    \hline
                    Wynik referencyjny & - & - & - & 423.741 & - \\
                    \hline
                \end{tabular}
                \label{tab:impl-tsp-results-oliver}
            \end{table}

            \begin{table}[H]
                \centering
                \caption{Uzyskane rozwiązania problemu \textit{kroa100}}
                \begin{tabular}{ |l|c c c|c c| }
                    \hline
                    & \multicolumn{3}{c|}{średnia z 10} & \multicolumn{2}{c|}{najlepszy wynik} \\
                    \hline
                    Rodzaj systemu & rozwiązanie & $\sigma$ & iteracja & rozwiązanie & iteracja \\
                    \hline
                    \textit{Ant Density} & 25217.165 & 766.781 & 59 & 24036.602 & 38 \\
                    \textit{Ant Quantity} & 22783.5697 & 164.390 & 432 & 22608.320 & 833 \\
                    \textit{Ant Cycle} & 22706.715 & 216.838 & 214 & 22327.793 & 178 \\
                    \textit{Ant Colony} & 22927.429 & 313.364 & 229 & 22526.941 & 679 \\
                    \textit{Max-min Ant System} & 21628.440 & 199.410 & 380 & 21377.504 & 354 \\
                    \hline
                    Wynik referencyjny & - & - & - & 21282 & - \\
                    \hline
                \end{tabular}
                \label{tab:impl-tsp-results-kroa}
            \end{table}
            %
        }
        %
    }
    %
}
