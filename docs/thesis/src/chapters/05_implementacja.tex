\chapter{Aplikacja steganograficzna wykorzystująca systemy mrówkowe}\label{chap:implementation}
{
    % wykorzystane narzędzia
    %   - co to jest X
    %   - zalety/wady
    %       - rust
    %           - kilka cech (iteratory, typy, zarządzanie pamięcią, obsługa błędów, null-safety, brak dziedziczenia)
    %
    % specyfikacja zewnętrzna
    %   - uruchamianie
    %   - parametry
    %   - format danych wejściowych
    %   - format danych wyjściowych
    %   - przykłady użycia
    %
    % specyfikacja wewnętrzna
    %   - opis modułów
    %   - opis najważniejszych struktur (graf, mrowisko, itp)
    %   - opis najważniejszych cech (trait) (i krótko i implementacjach (?))
    %
    % walidacja i testowanie
    %   - jak przetestowano aplikację
    %       - unity
    %       - property based testy
    %   - kompilacja jako walidacja (memory & type safety)

    % WYKORZYSTANE NARZĘDZIA
    Do implementacji aplikacji umożliwiającej ukrywanie danych w obrazach cyfrowych za pomocą przedstawionych metod
    wykorzystano język \textit{Rust}. \textit{Rust} jest kompilowanym językiem niskiego poziomu, którego kod wynikowy
    nie jest uruchamiany za pomocą maszyny wirtualnej. Nie posiada również mechanizmu odśmiecania pamięci (ang.
    \textit{garbage collection}) ani automatycznego zliczania referencji. Przeciwnie do języków \textit{C} oraz
    \textit{C++} obowiązek zarządzania pamięcią i gwarantowania bezpieczeństwa jej użycia przeniesiony z dewelopera na
    rygorystyczny kompilator.

    Głównymi celami realizowanymi przez język \textit{Rust} jest umożliwienie pisania aplikacji wymagających dużej
    wydajności, współbieżności oraz bezpieczeństwa przy wykorzystaniu nowoczesnych praktyk programistycznych. Kolejnym
    atutem tego języka jest wbudowany manager pakietów \textit{Cargo} umożliwiający bezproblemowe korzystanie z bogatego
    wachlarza otwartoźródłowych bibliotek.

    \textit{Rust} jest językiem wieloparadygmatowym, lecz wiele cech będących fundamentem jego popularności oraz
    bezpieczeństwa czerpie z języków funkcyjnych. Umożliwia pisanie wydajnego i deklaratywnego kodu dzięki rozbudowanym
    iteratorom (analogicznych do przetwarzania strumieniowego z języka \textit{Java}), oraz algebraicznym typom danych.
    Ważną decyzją podjętą podczas projektowania języka było zdecydowanie się na wykorzystanie monad \textit{Option} oraz
    \textit{Result}, co pozwoliło na rezygnację z mechanizmu wyjątków, zapewnienie bezwarunkowego \textit{null
    safety} oraz umożliwienie kompilatorowi wychwycenia znacznej części najczęściej popełnianych błędów.

    Ekspresywny system typów pozwala na pisanie rozszerzalnego i generycznego kodu. Język \textit{Rust} pozbawiony jest
    mechanizmu dziedziczenia, które nadużywane może być źródłem nieoczekiwanych zachowań oraz błędów związanych z
    dzieleniem stanu pomiędzy poszczególnymi klasami bazowymi oraz konfliktami nazw. Alternatywnym rozwiązaniem
    pozwalającym na ponowne wykorzystanie zachowań są cechy (ang. \textit{trait}). Cechy umożliwiają jedynie
    współdzielenie interfejsu oraz domyślnych implementacji funkcji związanych z typem danych, lecz nie pozwalają na
    współdzielenie stanu. Są mechanizmem zbliżonym do klas typów (ang. \textit{typeclasses}) znanych z języka
    \textit{Haskell}.


    % SPECYFIKACJA ZEWNĘTRZNA
    % zdecydować się na konsolę vs ui
    \section{Specyfikacja zewnętrzna}
    {

    }

    % SPECYFIKACJA WEWNĘTRZNA
    \section{Specyfikacja wewnętrzna}
    {
        Kod źródłowy aplikacji został podzielony w taki sposób, że odzwierciedla poruszane domeny. Powstały trzy główne
        moduły aplikacji: moduł systemu mrówkowego (\textit{ant\_colony}), moduł przetwarzania obrazów (\textit{images})
        i moduł steganograficzny (\textit{steganography}).


        \subsection{Moduł systemu mrówkowego}
        {
            W powyższym module zawarto implementację generycznego systemu mrówkowego, który jest parametryzowany
            strategiami wyboru krawędzi oraz nanoszenia śladu feromonowego. W ten sposób możliwe było efektywne
            zaimplementowanie wszystkich testowanych modeli systemów: z feromonem stałym, średnim, cyklicznym, systemu
            mrowiskowego oraz systemu max-min.

            % ANT-DISPATCHER
            Strategie wyboru krawędzi określone są cechą (ang. \textit{trait}) \textbf{AntDispatcher}. Jest to interfejs
            wymagający od każdej implementującej go struktury zapewnienia funkcji wybierającej kolejną krawędź dla
            wskazanej mrówki, grafu oraz śladu feromonowego. Cecha posiada również domyślną implementację funkcji
            odpowiedzialnej za umieszczenie zadanej liczby mrówek na wierzchołkach grafu w sposób losowy.

            Strukturami implementującymi cechę \textbf{AntDispatcher} są:

            \begin{itemize}
                \item \textit{BasicAntDispatcher} implementująca wzór \ref{eqt:edge_dispatch_propab} dla $\alpha = \beta
                = 1$,
                \item \textit{BiasedAntDispatcher} implementująca wzór \ref{eqt:edge_dispatch_propab}, jest
                wykorzystywana w wszystkich systemach z wyjątkiem systemu mrowiskowego,
                \item \textit{ColonyAntDispatcher} implementująca zasadę wyboru krawędzi w systemie mrowiskowym, będącą opisaną wzorem \ref{eqt:ant_colony_dispatch}.
            \end{itemize}

            % PHEROMONE-UPDATER
            Kolejną kluczową cechą należącą do tego modułu jest \textbf{PheromoneUpdater}, opisująca strategie
            odkładania śladu feromonowego na skutek ruchu mrówek. Interfejs wymaga implementacji funkcji inicjalizacji
            struktury feromonu, jego aktualizacji po wykonaniu kroku przez wszystkie mrówki oraz po wykonaniu całego
            cyklu. Dwie ostatnie funkcje mają domyślną postać funkcji identycznościowej.

            Powyższa cecha jest implementowana przez następujące struktury:

            \begin{itemize}
                \item \textit{ConstantPheromoneUpdater} nanoszący stała wartość na każdą odwiedzoną krawędź grafu, jest
                opisany wzorem \ref{eqt:pheromone-density},
                \item \textit{AveragePheromoneUpdater} odpowiada modelowi o feromonie średnim, opisanym wzorem \ref{eqt:pheromone-quantity},
                \item \textit{CyclicalPheromoneUpdater} aktualizujący ślad dla krawędzi w proporcji do długości trasy do
                której należy (wzór \ref{eqt:pheromone-cycle}),
                \item \textit{ColonyPheromoneUpdater} nanoszący ślad w każdym kroku algorytmu oraz po zakończeniu cyklu
                dla krawędzi należących do najkrótszej ścieżki (wzór \ref{eqt:pheromone-cycle}),
                \item \textit{MaxMinPheromoneUpdater} implementujący logikę aktualizacji śladu feromonowego w systemie
                max-min (wzór \ref{eqt:ant_colony_global_update_2} oraz \ref{eqt:ant_colony_local_update_2}).
            \end{itemize}

            Kolejnym ważnym elementem powyższego modułu jest struktura śladu feromonowego \textbf{Pheromone}. Jej
            implementacja jest oparta o tablicę asocjacyjną (ang. \textit{HashMap}) przypisująca każdego
            identyfikatorowi krawędzi wartość zmiennoprzecinkową. Zawiera metody umożliwiające skalowanie,
            inkrementację i normalizację wartości mapy.

            Ostatnim istotnym elementem modułu systemu mrówkowego jest struktura reprezentująca graf. Jego implementacja
            również wykorzystuje tablicę asocjacyjną, której kluczami są identyfikatory wierzchołków a wartościami
            struktury wierzchołków zawierające listę sąsiedztwa.
        }

        \subsection{Moduł przetwarzania obrazów}
        {
            Wszelkie operacje związane z odczytem i manipulacją obrazów zostały zawarte w module \textbf{images}. Można
            w nim wyszczególnić strukturę \textbf{Image} oraz związane z nią funkcje pozwalające na wczytywanie obrazu z
            dysku, manipulację rozmiarem oraz przekształcenie do struktury \textbf{PixelMap} będącej wygodną abstrakcją
            nad bitmapami \textit{RGB}. Struktura \textbf{PixelMap} pozwala na iterację kolejnych pikseli, iterację
            pikseli sąsiadujących z wskazanymi współrzędnymi, dowolne przekształcenie każdego piksela za pomocą
            przekazanej funkcji oraz wyznaczenie negatywu obrazu.

            Najbardziej złożoną częścią tego modułu jest cecha \textbf{ImageGraphConverter} oraz implementujące je
            struktury. Jej zadaniem przekształcenie dowolnej instancji bitmapy do grafu oraz przekształcenie śladu
            feromonowego w macierz maskującą, która jest reprezentowana przez instancję struktury \textbf{PixelMap}.

            Do struktur implementujących powyższą cechę należą:

            \begin{itemize}
                \item \textit{SpatialEdgeChangeConverter} implementująca metodę opisaną w sekcji
                \ref{subsec:vertex-method},
                \item \textit{WindowToEdgeConverter} odpowiedzialną za segmentację obrazu na nienachodzące na siebie
                prostokąty, opisaną w sekcji \ref{subsec:edge-method},
                \item \textit{KMeansConverter} dzielącą obraz na grupy pikseli o zbliżonej wariancji sąsiadujących pikseli,
                \item \textit{SuperPixelConverter} segmentująca obraz na zadaną ilość superpikseli według algorytmu
                \textit{SLIC}.
            \end{itemize}
        }

        \subsection{Moduł steganograficzny}
        {
            Ostatnim modułem aplikacji jest moduł odpowiedzialny za ukrywanie informacji w wskazanej bitmapie na
            podstawie macierzy maskującej. Za równo bitmapa jak i macierz maskująca jest reprezentowana przez struktury
            \textbf{PixelMap}. Strukturą implementującą powyższą funkcjonalność jest \textbf{MaskImageEmbedder}. W
            trakcie ukrywania informacji wykorzystywany jest iterator bitów pozwalający na odczyt zadanej ilości
            kolejnych bitów wiadomości.

            W module zawarto również implementację podstawowych miar jakości obrazów, takich jak błąd średniokwadratowy
            i szczytowy stosunek sygnału do szumu.
        }
    }



    % WALIDACJA I TESTOWANIE
    \section{Walidacja i testowanie}
    {
        W celu zapewnienia pożądanego działania oraz powtarzalności rezultatów aplikacja została w znacznym stopniu
        pokryta testami jednostkowymi. Umożliwiło to natychmiastowe wykrycie nieoczekiwanych zmian w działaniu programu
        oraz umożliwiło dynamiczny rozwój kolejnych modułów aplikacji.

        Kolejnym istotnym zagadnieniem związanym z wykorzystanymi metodami zapewnienia jakości oprogramowania są testy
        oparte o właściwości (ang. \textit{property based testing}). Jest to technika polegająca na testowaniu kodu dla
        bardzo dużej ilości generowanych losowo danych wejściowych i sprawdzaniu czy pewne fundamentalne założenia
        dotyczące danych wyjściowych są wciąż spełnione. Przykładowo, test oparty o właściwość funkcji sortującej
        tablicę zawierającą wartości liczbowe może sprawdzać czy każdy kolejny element posortowanej tablicy jest większy
        bądź równy poprzedniemu. W ten sposób jesteśmy w stanie zweryfikować działanie kodu bez określania konkretnych
        zestawów danych.

        W aplikacji wykorzystano testy oparte o właściwości do zapewnienia odwracalności procesu ukrywania i wydobywania
        danych z obrazu (złożenie funkcji ukrywającej i funkcji wydobywającej powinno być funkcją identycznościową z
        względu na argument ukrywanych danych) oraz zapewniania unikalności generowanych identyfikatorów krawędzi
        łączących wskazane wierzchołki grafu za pomocą metody zaproponowanej przez M. Szudzik\cite{SzudzikFn}.

        \subsection{Rozwiązywanie problemu komiwojażera}
        {
            %
            Aby zweryfikować poprawność implementacji modułu systemu mrówkowego postanowiono sprawdzić jego efektywność
            w rozwiązywaniu problemu komiwojażera. Krok ten również umożliwił implementację pomocniczych heurystyk
            służących do automatycznego doboru parametrów strategii wyboru krawędzi przez mrówki oraz odkładania śladu
            feromonowego. Uzyskane zależności wyprowadzono na postawie eksperymentów wskazówek znajdujących się w
            pracach opisujących poszczególne systemy mrówkowe\cite{Dorigo1991AntSA, Dorigo1997AntCS,
            Sttzle2000MAXMINAS}.

            W tabeli \ref{tab:impl-tsp-results} zamieszczono uzyskane rezultaty znanych z literatury problemów o
            trzydziestu (\textit{oliver30}) i stu miastach (\textit{kroa100}), wraz z powszechnie znanymi najlepszymi
            rozwiązaniami. Parametry poszczególnych wariantów systemów mrówkowych były konfigurowane za pomocą
            opracowanych heurystyk. Przyjęto również że ilość mrówek jest równa ilości wierzchołków grafu.

            \begin{table}
                \centering
                \begin{tabular}{ |l|c c|c c| }
                    \hline
                    & \multicolumn{2}{c|}{\textit{oliver30}} & \multicolumn{2}{c|}{\textit{kroa100}} \\
                    \hline
                    Rodzaj systemu & rozwiązanie & iteracja & rozwiązanie & iteracja \\
                    \hline
                    \textit{Ant Density} & 446.87012 & 18 & 25606.107 & 30 \\
                    \textit{Ant Quantity} & 426.54388 & 185 & 23150.693 & 162 \\
                    \textit{Ant Cycle} & 429.2246 & 119 & 22826.52 & 82 \\
                    \textit{Ant Colony} & 435.7622 & 178 & 23401.607 & 121 \\
                    \textit{Max-min Ant System} & 424.69177 & 84 & 22075.67 & 221 \\
                    \hline
                    Wynik referencyjny & 423.741 & - & 21282 & - \\
                    \hline
                \end{tabular}
                \caption{Uzyskane rozwiązania problemów \textit{oliver30} oraz \textit{kroa100}.}
                \label{tab:impl-tsp-results}
            \end{table}
            %
        }
        %
    }
    %
}
